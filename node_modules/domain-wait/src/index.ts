import { domainTasksStateKey, completedTasksKey } from "./Constants";
import { isNode, transformUrl, getHashCode } from "./utils";
import { IDomainTasksState } from "./IDomainTasksState";

import * as domain from 'domain';
import * as domainContext from 'domain-context';
import { options } from "./options";

var nodeData: IData = null;

export interface IData {
    completedTasks: string[];
}

export interface INodeServicesBootFuncParams {
    /**
     * Origin URL.
     * */
    origin: string;
    data: any;
}

/**
 * Connect 'domain-wait' library with the NodeServices params.
 * @param nodeServicesBootFuncParams 'params' argument of the function 'createServerRenderer'.
 */
export function addDomainWait(nodeServicesBootFuncParams: INodeServicesBootFuncParams): void {
    if (!nodeServicesBootFuncParams) {
        throw Error(`"nodeServicesBootFuncParams" is null.`);
    }
    if (!nodeServicesBootFuncParams.data) {
        nodeServicesBootFuncParams.data = {
            completedTasks: []
        };
    }
    nodeData = nodeServicesBootFuncParams.data;
    if (!nodeData.completedTasks) {
        nodeData.completedTasks = [];
    }
}

/**
 * Get hash codes of completed tasks.
 * */
export function getCompletedTasks(): string[] {
    if (isNode()) {
        if (!nodeData || !nodeData.completedTasks) {
            return [];
        }
        return nodeData.completedTasks;
    }
    return window[completedTasksKey];
}

/**
 * Wait for the asynchronous function in NodeServices prerender process.
 * @param task Asynchronous function. Use the 'transformUrlFn' function in internal requests (in your web application) for the URL transformation.
 * @param taskKey String key which is used to prevent the execution of methods on client side after SSR.
 */
export async function wait(taskFn: (transformUrlFn: (url: string) => string) => Promise<any>, taskKey: string) {

    if (!taskFn) {
        throw Error(`"task" is null.`)
    }

    if (!taskKey || taskKey == "") {
        throw Error(`"taskKey" is null of empty.`);
    }

    options.logFn(`Start executing task "${taskKey}".\nFunction:\n ${taskFn.toString()}`);

    if (!isNode()) {

        // In browser.

        options.logFn(`Executing task "${taskKey}" in browser.`);

        var _completedTasks = window[completedTasksKey];
        if (_completedTasks) {
            var completedTaskIndex = _completedTasks.indexOf(taskKey);
            if (completedTaskIndex > -1) {
                // Prevent execution of the task that was completed in Node.
                options.logFn(`Prevent execution task "${taskKey}" in browser.`);
                _completedTasks.splice(completedTaskIndex, 1);
                window[completedTasksKey] = _completedTasks;
                return;
            }
        } else {
            console.log(
                `domain-wait: Array "window.${completedTasksKey
                }" not defined. Define it to use the "wait" method. This will prevent the execution of methods on client side after SSR.`);
        }

        await taskFn(transformUrl);

        options.logFn(`Task "${taskKey}" completed in browser.\nCompleted Node tasks: ${JSON.stringify(_completedTasks)}`);

    } else if (domain.active) {

        // In Node.

        if (!domainContext) {
            options.logFn(`Critical error while executing task "${taskKey}" in Node.`);
            throw Error("Domain context of the NodeServices has been lost. Possibly you try to acquire it in incorrect way.");
        }

        const state = domainContext.get(domainTasksStateKey) as IDomainTasksState;

        if (!state) {
            options.logFn(`Critical error while executing task "${taskKey}" in Node.`);
            return;
        }

        state.numRemainingTasks++;

        try {

            options.logFn(`Executing task "${taskKey}" asynchronously in Node.`);

            // Execute task asynchronously in Node.
            await taskFn(transformUrl);

            if (nodeData.completedTasks.indexOf(taskKey) === -1) {
                nodeData.completedTasks.push(taskKey);
            }

            options.logFn(`Task "${taskKey}" completed in Node.`);

            setTimeout(() => {

                state.numRemainingTasks--;

                if (state.numRemainingTasks === 0 && !state.hasIssuedSuccessCallback) {

                    // All tasks completed successfully.

                    state.hasIssuedSuccessCallback = true;

                    setTimeout(() => {
                        state.completionCallback(null);
                    }, 0);
                }

            }, 0);

        } catch (error) {
            options.logFn(`Error while executing task "${taskKey}" in Node.`);
            state.completionCallback(error);
        }
    }

    return;
}